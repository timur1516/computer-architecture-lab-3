    .data

stack_top:       .word  0x200                       ; Вершина стека
input_addr:      .word  0x80             
output_addr:     .word  0x84

    .text
    .org        0x100

_start:
    movea.l     stack_top, A7                       ; Инициализация указателя стека
    movea.l     (A7), A7
    movea.l     input_addr, A0                      ; Загрузка адреса входных данных
    movea.l     (A0), A0
    movea.l     output_addr, A1                     ; Загрузка адреса для вывода результата
    movea.l     (A1), A1

    move.l      (A0), -(A7)                         ; Помещаем число из ввода на стек для вызова функции abs
    jsr         abs                                 ; Вызов функции abs для получения абсолютного значения числа
    move.l      (A7)+, D1                           ; Освобождаем стек после вызова функции abs

    move.l      D0, -(A7)                           ; Помещаем число по модулю на стек для вызова функции sum_of_digits
    jsr         sum_of_digits                       ; Вызов функции sum_of_digits для получения суммы цифр
    move.l      (A7)+, D1                           ; Освобождаем стек после вызова функции sum_of_digits

    move.l      D0, (A1)                            ; Выводим сумму цифр в выходной адрес
    halt

; Вычисление суммы цифр числа
; Аргумент находится на вершине стека
; Возвращаемое значение хранится в D0
sum_of_digits:
    link        A6, -16                             ; Выделяем стековый фрейм с четырмя дополнительными локальными переменными
    move.l      8(A6), -4(A6)                       ; Записываем входное значение в локальную переменную 
    move.l      0, D0                               ; Инициализируем сумму цифр в D0
    move.l      10, -16(A6)                         ; Записываем в последнюю локальную перменную константу 10                 

sum_of_digits_cycle:
    cmp.l       0, -4(A6)                           ; Если число равно 0, завершаем цикл
    beq         sum_of_digits_end

    move.l      -4(A6), -8(A6)                      ; Копируем число для дальнейшего вычисления остатка
    div.l       -16(A6), -4(A6)                     ; Делим число на 10
    move.l      -4(A6), -12(A6)                     ; Сохраняем частное в локальную переменную
    mul.l       -16(A6), -12(A6)                    ; Умножаем частное на 10
    sub.l       -12(A6), -8(A6)                     ; Вычисляем остаток от деления

    add.l       -8(A6), D0                          ; Добавляем остаток к сумме цифр

    jmp         sum_of_digits_cycle                 ; Переходим к следующей итерации цикла

sum_of_digits_end:
    unlk        A6                                  ; Освобождаем стековый фрейм
    rts                                             ; Возвращаемся из функции    


; Взятие числа по модулю
; Аргумент находится на вершине стека
; Возвращаемое значение хранится в D0
abs: 
    link        A6, 0                               ; Выделяем стековый фрейм
    move.l      8(A6), D0                           ; Получаем число из стека
    cmp.l       0, D0                               ; Сравниваем с нулем 
    bge         abs_end                             ; Если число больше или равно нулю, выходим  
    not.l       D0                                  ; Если число отрицательное, меняем его знак
    add.l       1, D0
abs_end:
    unlk        A6                                  ; Освобождаем стековый фрейм
    rts                                             ; Возвращаемся из функции        